<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8" />
<title>Fret position Calculator | Fido Lab</title>
<meta name="author" content="Martin Fido" />
<meta name="description" content="A calculator to provide fret position measurements when building stringed instruments" />
<link rel="SHORTCUT ICON" href="/favicon.ico" />
<style type="text/css">
body { background-color:#e6e6e6; }
table { border-collapse:collapse; }
table, th, td { border: 1px solid black; }
th, td { padding: 2px; }
td { text-align: right; }
</style>
<script type="text/javascript">

const pythagorean_comma = Math.pow(3, 12) / Math.pow(2, 19);
const syntonic_comma = 81 / 80;

const biggest_denom = 131072;

class Note {
  constructor(name, ratio, cents) {
    this.name = name;
    this.ratio = ratio;
    this.cents = cents;
  }

  static ofRatio(name, ratio, normalize) {
    if (normalize) {
      while (ratio < 1) { ratio *= 2; }
      while (ratio >= 2) { ratio /= 2; }
    }
    let cents = Math.log(ratio) * (1200 / Math.LN2);
    return new Note(name, ratio, cents);
  }

  static ofCents(name, cents, normalize) {
    if (normalize) {
      cents %= 1200; // check this works for negative numbers
    }
    let ratio = Math.exp(cents / (1200 * Math.LOG2E));
    return new Note(name, ratio, cents);
  }

  // parse note name and cents or ratio, e.g. "F:498.04" or "C#:25/24"
  static parse(str) {
    let name = str;
    let parts = str.split(":");
    if (parts.length === 2) {
      name = parts[0];
      str = parts[1];
    }
    let fraction = str.split("/");
    if ((fraction.length === 2) && !isNaN(fraction[0]) && !isNaN(fraction[1])) {
      return Note.ofRatio(name, fraction[0] / fraction[1], true);
    }
    let num = Number(str);
    if (!Number.isNaN(num)) {
      return Note.ofCents(name, num, true);
    }
    return null;
  }

  ratio_str() {
    return this.ratio.toFixed(13).replace(/\.?0+$/, '');
  }

  cent_str() {
    return this.cents.toFixed(3);
  }

  cent_offset_str() {
    var hundreds = Math.round(this.cents / 100) * 100;
    var offset = this.cents - hundreds;
    return hundreds + ((offset >= 0) ? '+' : '') + offset.toFixed(3);
  }

  static almostInt(num) {
    // TODO optimise this
    // num % 1 then check if close to 0 or close to 1?
    let fix = num.toFixed(13)
    let rnd = fix.replace(/\.0+$/, '');
    //console.log(num + ' -> ' + res);
    return (fix.length !== rnd.length) ? rnd : null;
  }

  fraction_str() {
    let re = new RegExp('\.0+$', 'i');
    for (let bot = 1; bot < 50; bot++) {
      let top = Note.almostInt(this.ratio * bot);
      if (top) {
        return top + '/' + bot; 
      }
    }
    return null;
  }
}

class Temperament {

}

// Scale create functions

function equal_temperament(notes_per_octave) {
  var notes = [];
  for (var i = 0; i < notes_per_octave; i++) {
    notes.push(Note.ofCents(i, 1200 * i / notes_per_octave));
  }
  return notes;
}

function meantone(comma, division) {
  let major_fifth = (3 / 2) / Math.pow(comma, division);
  let whole_tone = major_fifth * major_fifth / 2;
  let major_third = whole_tone * whole_tone; // major_sixth * major_fifth / 2
  let major_fourth = 2 / major_fifth; // major_fifth / whole_tone;
  let major_sixth = whole_tone * major_fifth;
  let major_seventh = major_third * major_fifth; // major_sixth * whole_tone;
  let diatonic_semitone = 2 / major_seventh;
  let chromatic_semitone = whole_tone / diatonic_semitone;

  //let names = [ 'C', 'D', 'E', 'F', 'G', 'A', 'B' ];
  let names = [ '1', '2', '3', '4', '5', '6', '7' ];
  let notes = [];

  function add(name, ratio) {
    notes.push(Note.ofRatio(name, ratio));
    notes.push(Note.ofRatio(name + '♯', ratio * chromatic_semitone));
    notes.push(Note.ofRatio(name + '♭', ratio / chromatic_semitone, true));
  }

  add(names[0], 1);
  add(names[1], whole_tone);
  add(names[2], major_third);
  add(names[3], major_fourth);
  add(names[4], major_fifth);
  add(names[5], major_sixth);
  add(names[6], major_seventh);

  notes.sort(function(a, b) { return a.ratio - b.ratio; });
  return notes;
}

function bach_lehman_1722() {
  const pure_fifth = 3 / 2;
  const narrow_fifth = pure_fifth / Math.pow(pythagorean_comma, 1 / 6);
  const half_narrow_fifth = pure_fifth / Math.pow(pythagorean_comma, 1 / 12);
  const names = [ 'C', 'C♯', 'D', 'E♭', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'B♭', 'B' ];

  let notes = [];
  let i = 5; // start on the major fourth
  let ratio = 1 / narrow_fifth;

  for (; i < (5 * 7); i += 7) {
    notes.push(Note.ofRatio(names[i % 12], ratio, true));
    ratio *= narrow_fifth;
  }
  for (; i < (8 * 7); i += 7) {
    notes.push(Note.ofRatio(names[i % 12], ratio, true));
    ratio *= pure_fifth;
  }
  for (; i < (12 * 7); i += 7) {
    notes.push(Note.ofRatio(names[i % 12], ratio, true));
    ratio *= half_narrow_fifth;
  }

  notes.sort(function(a, b) { return a.ratio - b.ratio; });

  return notes;
}

function custom_temperament(note_list) {
  let notes = [];
  for (let str of note_list.split(" ")) {
    let note = Note.parse(str);
    if (note) {
      notes.push(note);
    }
  }
  notes.sort(function(a, b) { return a.ratio - b.ratio; });
  return notes;
}

// Fret table functions

function update_scale() {
  let scale_length = document.getElementById('sl').value;

  if (isNaN(scale_length) || (scale_length <= 0)) {
    return;
  }

  let table = document.getElementById('frets');
  let notes = [];

  switch (document.getElementById('temperament').value) {
    case 'equal': {
      let notes_per_octave = document.getElementById('npo').value;
      if (isNaN(notes_per_octave) || (notes_per_octave < 1)) {
        return null;
      }
      notes = equal_temperament(notes_per_octave);
      break;
    }
    case 'meantone': {
      let comma = document.getElementById('comma').value == 's' ? syntonic_comma : pythagorean_comma;
      let division = 1 / document.getElementById('division').value;
      notes = meantone(comma, division);
      break;
    }
    case 'lehman': {
      notes = bach_lehman_1722();
      break;
    }
    default: {
      let note_list = document.getElementById('cs').value;
      notes = custom_temperament(note_list);
      break;
    }
  }

  // remove all but the table header
  while (table.rows.length > 2) {
    table.deleteRow(-1);
  }

  for (let fret_number = 0; fret_number < notes.length; fret_number++) {
    let note = notes[fret_number];
    let row = table.insertRow(-1);

    let col = 0;
    let cell = row.insertCell(col++);
    cell.innerHTML = note.name;
    cell.style.textAlign = 'left';

    row.insertCell(col++).innerHTML = note.fraction_str();
    row.insertCell(col++).innerHTML = note.ratio_str();
    row.insertCell(col++).innerHTML = note.cent_str();
    row.insertCell(col++).innerHTML = note.cent_offset_str();

    for (let octave = 0; octave < 1; octave++) {
      let ratio = note.ratio * Math.pow(2, octave);
      let frequency = ratio * 110;
      row.insertCell(col++).innerHTML = frequency.toFixed(3);
    }

    for (let octave = 0; octave < 3; octave++) {
      let position = scale_length - (scale_length / (note.ratio * Math.pow(2, octave)));
      row.insertCell(col++).innerHTML = position.toFixed(5);
    }
  }
}

function select_scale() {
  let sel = document.getElementById('temperament').value;
  document.getElementById('equalparam').style.display = (sel === 'equal') ? 'block' : 'none';
  document.getElementById('meantoneparam').style.display = (sel === 'meantone') ? 'block' : 'none';
  document.getElementById('customparam').style.display = (sel === 'custom') ? 'block' : 'none';
  update_scale();
}

const params = [ 'npo', 'sl'];

function got_input() {
  if (!document.getElementById('a').checked) {
    return;
  }
  update_pressed();
}

function update_pressed() {
  if (window.history.replaceState) {
    let query = '';
    for (let i in params) {
      let p = params[i];
      if (query !== '') query += '&';
      query += p + '=' + document.getElementById(p).value;
    }
    window.history.replaceState({}, null, '?' + query);
  }
  update_scale();
}

// Entry point

window.onload = function() {
  function get(q) {
    let s = window.location.search;
    let re = new RegExp('&' + q + '=([^&]*)', 'i');
    return (s = s.replace(/^\?/, '&').match(re)) ? s = s[1] : s = '';
  }

  for (let i in params) {
    let p = params[i];
    let v = get(p);
    if (v !== '') {
      document.getElementById(p).value = v;
    } else {
      v = document.getElementById(p).value;
    }
  }

  select_scale();
}
</script>
</head>
<body>
  <header>
    <a href="/">Fido Lab</a>
  </header>
</br>
<noscript>
  <pre id="noscript-warning" style="border: 10px solid red; background-color: black; color: white; text-align: center;">

      Sorry, this page only works on modern browsers with JavaScript enabled.
      If you need a new browser, you might like to try <a href="https://www.mozilla.org/firefox/">Mozilla Firefox</a>.
      If you're using e.g. NoScript due to security or privacy concerns,
      note that all of the JS on this site is inlined in the html and shouldn't take long to audit.
  </pre>
</noscript>
This is a fret position calculator to help locate fret slots when building stringed instruments. A variety of
temperaments are supported including meantone and pure intonation.
<p>Temperament:
<select id="temperament" onchange="select_scale()">
  <option value="equal">Equal Temperament / Division</option>
  <option value="meantone">Meantone</option>
  <option value="lehman">Bach Lehman 1722 (larips.com)</option>
  <option value="custom">Custom (Pure Intonation)</option>
</select></p>
<p id="equalparam">
  Notes per Octave: <input id="npo" type="number" name="Notes per Octave" value="12" onchange="got_input()">
</p>
<p id="meantoneparam">
  Comma: <select id="comma" onchange="got_input()">
  <option value="s" selected="selected">Syntonic</option>
  <option value="p">Pythagorean</option>
  </select>&nbsp;&nbsp;
  Division: <select id="division" onchange="got_input()">
  <option value="3">1/3</option>
  <option value="3.5">2/7</option>
  <option value="4" selected="selected">1/4</option>
  <option value="5">1/5</option>
  <option value="6">1/6</option>
  </select>
</p>
<p id="customparam">
  Notes: <input id="cs" type="text" name="custom temperament" size="80" value="C:1/1 C♯:25/24 10/9 D:9/8 32/27 E♭:6/5 E:5/4 F:4/3 25/18 F♯:45/32 G:3/2 G♯:25/16 A:5/3 16/9 B♭:9/5 B:15/8" onchange="got_input()">
</p>
<p>
  Root Frequency: <input id="rf" type="text" name="root frequency" value="110" onchange="got_input()">Hz&nbsp;&nbsp;
  Root Note: <select id="rn" onchange="got_input()"></select>
</p>
<p>
  Scale Length: <input id="sl" type="text" name="scale length" value="25.5" onchange="got_input()">
</p>
<p>
  <input type="button" id="updatebutton" value="update" onclick="update_pressed()">
  <input type="checkbox" id="a" value="auto" onclick="got_input()"> automatic
</p>
<table id="frets">
  <tr>
    <th rowspan="2">Fret / Name</th>
    <th rowspan="2" colspan="2">Ratio</th>
    <th rowspan="2" colspan="2">Cents</th>
    <th rowspan="2">Frequency</th>
    <th colspan="3">Distance from Nut</th>
  </tr>
  <tr>
    <th>First Octave</th>
    <th>Second Octave</th>
    <th>Third Octave</th>
  </tr>
</tr>
</table>
</body>
</html>
